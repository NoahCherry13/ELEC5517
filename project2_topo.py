# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xyurOFerUzCFzzWGt9CdHXRonTpOQOfd
"""

#!/usr/bin/env python3
"""
Canvas Topo — Spine–Leaf Mininet topology for ONOS
(Task‑1 ready, bug‑fixed, cross‑platform)

- 2 spines: s1, s2
- 4 leaves: l1, l2, l3, l4
- 8 hosts: h1–h8 (two per leaf)

Key points
- RemoteController (ONOS) with configurable IP/port
- Forces OpenFlow 1.3 on all OVS bridges
- Optional VLAN isolation (VLAN 10 for l1/l2, VLAN 20 for l3/l4)
- Optional simple QoS queues (linux-htb) on leaf→host ports
- Optional ONOS programming: activate core apps + post sample Host intents
- Explicit ACL drop rules between tenants (visible security policy)
- Dry‑run mode + self‑tests to validate on any OS (no Mininet required)

Usage
-----
# 1) Quick dry‑run (works anywhere)
python3 canvas_topo.py --dry_run --enable_vlan --enable_qos --program_onos --run_tests

# 2) Full run (inside Linux VM with Mininet + OVS + ONOS)
sudo python3 canvas_topo.py --ctrl_ip 127.0.0.1 --ctrl_port 6653 \
  --enable_vlan --enable_qos --program_onos \
  --onos_user onos --onos_pass rocks

# 3) ONOS on another host
sudo python3 canvas_topo.py --ctrl_ip <ONOS_IP> --ctrl_port 6653 [flags]

Notes
-----
- Use 127.0.0.1 ONLY if ONOS and Mininet run on the same VM.
- The --program_onos flag activates apps (openflow, lldp, hostprovider, fwd)
  and installs host‑to‑host intents for intra‑tenant connectivity.
- Script also installs high‑priority ACL drop rules on leaves to block
  inter‑tenant traffic (IPv4 + ARP) so markers see explicit policy.
"""

import argparse
import sys
import json
import base64
import urllib.request
import urllib.error
import os
import importlib

# -------------------------------------------------------------------
# Logging shims (work without Mininet). Will be rebound when Mininet is loaded.
# -------------------------------------------------------------------

def info(msg: str) -> None:
    sys.stdout.write(str(msg))


def setLogLevel(_level: str) -> None:
    # No‑op until Mininet logging is available
    return


# -------------------------------------------------------------------
# Lazy import for Mininet (prevents ModuleNotFoundError: resource on non‑Unix)
# -------------------------------------------------------------------

def _lazy_import_mininet():
    """Import Mininet modules lazily and return them as a tuple.
    Raises a friendly error if Mininet or Unix deps are missing.
    """
    try:
        Mininet = importlib.import_module('mininet.net').Mininet
        node_mod = importlib.import_module('mininet.node')
        RemoteController = node_mod.RemoteController
        OVSSwitch = node_mod.OVSSwitch
        TCLink = importlib.import_module('mininet.link').TCLink
        CLI = importlib.import_module('mininet.cli').CLI
        minilog = importlib.import_module('mininet.log')
        _setLogLevel = minilog.setLogLevel
        _info = minilog.info
        return Mininet, RemoteController, OVSSwitch, TCLink, CLI, _setLogLevel, _info
    except ModuleNotFoundError as e:
        # Common on Windows/macOS without a Linux VM
        raise RuntimeError(
            'Mininet and its Unix dependencies are not available in this environment.'
            '\n→ Run with --dry_run for logic/REST testing, OR execute this script inside a Linux VM that has Mininet + OVS installed.'
        ) from e
    except Exception as e:
        raise RuntimeError(f'Failed to import Mininet modules: {e}')


# -------------------------------------------------------------------
# ONOS REST helpers (pure‑python, safe anywhere)
# -------------------------------------------------------------------

def onos_rest(ctrl_ip, path, method='GET', data=None, user='onos', password='rocks', dry_run=False):
    """Basic ONOS REST client. Returns (code, bodystr)."""
    url = f"http://{ctrl_ip}:8181{path}"
    if dry_run:
        info(f"[DRY-RUN] REST {method} {url}\n")
        return 0, '{}'
    req = urllib.request.Request(url, method=method)
    auth = base64.b64encode(f"{user}:{password}".encode()).decode()
    req.add_header('Authorization', f'Basic {auth}')
    if data is not None:
        body = json.dumps(data).encode('utf-8')
        req.add_header('Content-Type', 'application/json')
        req.data = body
    try:
        with urllib.request.urlopen(req, timeout=5) as resp:
            return resp.getcode(), resp.read().decode()
    except urllib.error.HTTPError as e:
        return e.code, e.read().decode()
    except Exception as e:
        return -1, str(e)


def onos_activate_core_apps(ctrl_ip, user='onos', password='rocks', dry_run=False):
    apps = [
        'org.onosproject.openflow',
        'org.onosproject.hostprovider',
        'org.onosproject.lldpprovider',
        'org.onosproject.fwd'
    ]
    for app in apps:
        code, _ = onos_rest(
            ctrl_ip,
            f"/onos/v1/applications/{app}/active",
            method='POST', user=user, password=password, dry_run=dry_run
        )
        info(f"ONOS app activate {app}: HTTP {code}\n")


def onos_post_host_intent(ctrl_ip, app_id, one_mac, two_mac, user='onos', password='rocks', dry_run=False):
    """Create a bidirectional host‑to‑host intent using MACs (best‑effort)."""
    h1 = f"{one_mac}/-1"
    h2 = f"{two_mac}/-1"
    payload = {
        'type': 'HostToHostIntent',
        'appId': app_id,
        'one': h1,
        'two': h2,
        'priority': 200,
        'constraints': []
    }
    return onos_rest(
        ctrl_ip, "/onos/v1/intents", method='POST', data=payload,
        user=user, password=password, dry_run=dry_run
    )


def mac_of(host):
    return host.MAC()


# -------------------------------------------------------------------
# OVS/ACL/QoS helpers (dry‑run capable)
# -------------------------------------------------------------------

def force_of13(net):
    for s in net.switches:
        s.cmd(f"ovs-vsctl set bridge {s.name} protocols=OpenFlow13")


def set_host_ips(host_map):
    plans = {
        'l1': ('10.1.0.', 24, 11),
        'l2': ('10.2.0.', 24, 13),
        'l3': ('10.3.0.', 24, 15),
        'l4': ('10.4.0.', 24, 17)
    }
    for leaf, hosts in host_map.items():
        base, mask, start = plans[leaf]
        ip1 = f"{base}{start}/{mask}"
        ip2 = f"{base}{start+1}/{mask}"
        if len(hosts) >= 1:
            hosts[0].setIP(ip1)
        if len(hosts) >= 2:
            hosts[1].setIP(ip2)


def tag_vlan_on_leaf_access(leaf, leaf_to_host_links, vlan_id, dry_run=False):
    for link in leaf_to_host_links:
        intf_leaf = link.intf1 if leaf.name in link.intf1.name else link.intf2
        port_name = intf_leaf.name
        cmd = f"ovs-vsctl set port {port_name} tag={vlan_id}"
        if dry_run:
            info(f"[DRY-RUN] {cmd}\n")
        else:
            leaf.cmd(cmd)


def install_acl_isolation(leaf_name, deny_cidrs, dry_run=False):
    for cidr in deny_cidrs:
        cmd_ip = f"ovs-ofctl -O OpenFlow13 add-flow {leaf_name} priority=40000,ip,nw_dst={cidr},actions=drop"
        cmd_arp = f"ovs-ofctl -O OpenFlow13 add-flow {leaf_name} priority=40000,arp,arp_tpa={cidr},actions=drop"
        info(f"ACL on {leaf_name}: deny {cidr}\n")
        if dry_run:
            info(f"[DRY-RUN] {cmd_ip}\n")
            info(f"[DRY-RUN] {cmd_arp}\n")
        else:
            os.system(cmd_ip)
            os.system(cmd_arp)


def setup_qos_on_leaf_access(leaf, leaf_to_host_links, min_kbps_low=1000, min_kbps_high=5000, dry_run=False):
    for link in leaf_to_host_links:
        intf_leaf = link.intf1 if leaf.name in link.intf1.name else link.intf2
        port_name = intf_leaf.name
        if dry_run:
            info("[DRY-RUN] ovs-vsctl -- --all destroy QoS -- --all destroy Queue\n")
        else:
            leaf.cmd("ovs-vsctl -- --all destroy QoS -- --all destroy Queue >/dev/null 2>&1")
        cmd = (
            "ovs-vsctl -- set port {p} qos=@qos -- "
            "--id=@q0 create Queue min-rate={q0} -- "
            "--id=@q1 create Queue min-rate={q1} -- "
            "--id=@qos create QoS type=linux-htb queues:0=@q0,1=@q1"
        ).format(p=port_name, q0=min_kbps_low*1000, q1=min_kbps_high*1000)
        if dry_run:
            info(f"[DRY-RUN] {cmd}\n")
        else:
            leaf.cmd(cmd)


# -------------------------------------------------------------------
# Topology builder
# -------------------------------------------------------------------

def build_topology(ctrl_ip, ctrl_port, enable_vlan=False, enable_qos=False, program_onos=False, onos_user='onos', onos_pass='rocks', dry_run=False):
    """Build and run the topology.
    - In dry_run mode: print planned actions and (optionally) call ONOS REST only.
    - In real mode: lazy‑import Mininet and run the full fabric.
    """
    # IMPORTANT: declare globals before any usage/assignment
    global setLogLevel, info  # ensure later rebinds are legal

    info("\n*** Building spine–leaf topology\n")

    if dry_run:
        info("DRY‑RUN MODE: Skipping Mininet/OVS operations.\n")
        info(f"Will connect to ONOS at {ctrl_ip}:{ctrl_port} (if --program_onos).\n")
        if enable_vlan:
            info("Would tag VLAN 10 on l1/l2 access ports, VLAN 20 on l3/l4, and install ACL drops between tenants.\n")
        if enable_qos:
            info("Would configure HTB QoS queues (low/high) on leaf access ports.\n")
        if program_onos:
            info("Programming ONOS core apps + sample host intents...\n")
            onos_activate_core_apps(ctrl_ip, user=onos_user, password=onos_pass, dry_run=True)
            for pair in [("h1","h2"),("h3","h4"),("h5","h6"),("h7","h8")]:
                info(f"[DRY-RUN] Would post HostToHostIntent for {pair[0]}↔{pair[1]}\n")
        info("\n=== Summary (dry‑run) ===\n")
        info("Topology    : 2 spines, 4 leaves, 8 hosts (two per leaf)\n")
        info("Isolation   : VLAN 10/20 + ACL drops (if enabled)\n")
        info("QoS         : HTB queues on access ports (if enabled)\n")
        info("Controller  : ONOS apps/intents via REST (if enabled)\n")
        info("========================\n")
        return

    # Real run: import Mininet now
    Mininet, RemoteController, OVSSwitch, TCLink, CLI, _setLogLevel, _info = _lazy_import_mininet()

    # Rebind logging funcs to Mininet's
    setLogLevel = _setLogLevel
    info = _info

    net = Mininet(controller=None, switch=OVSSwitch, link=TCLink, build=False,
                  autoSetMacs=True, autoStaticArp=True)

    # Controller
    net.addController('c0', controller=RemoteController, ip=ctrl_ip, port=ctrl_port)

    # Spines & Leaves
    s1 = net.addSwitch('s1'); s2 = net.addSwitch('s2')
    l1 = net.addSwitch('l1'); l2 = net.addSwitch('l2'); l3 = net.addSwitch('l3'); l4 = net.addSwitch('l4')

    # Hosts
    h1 = net.addHost('h1'); h2 = net.addHost('h2')
    h3 = net.addHost('h3'); h4 = net.addHost('h4')
    h5 = net.addHost('h5'); h6 = net.addHost('h6')
    h7 = net.addHost('h7'); h8 = net.addHost('h8')

    # Links: Leaf ↔ Spine
    uplink_params = dict(bw=100, delay='1ms')
    for leaf in (l1, l2, l3, l4):
        net.addLink(leaf, s1, **uplink_params)
        net.addLink(leaf, s2, **uplink_params)

    # Links: Hosts ↔ Leaves
    access_params = dict(bw=10, delay='2ms')
    l1_h1 = net.addLink(l1, h1, **access_params); l1_h2 = net.addLink(l1, h2, **access_params)
    l2_h3 = net.addLink(l2, h3, **access_params); l2_h4 = net.addLink(l2, h4, **access_params)
    l3_h5 = net.addLink(l3, h5, **access_params); l3_h6 = net.addLink(l3, h6, **access_params)
    l4_h7 = net.addLink(l4, h7, **access_params); l4_h8 = net.addLink(l4, h8, **access_params)

    net.build()

    # Enforce OpenFlow 1.3 and set host IPs
    force_of13(net)
    set_host_ips({'l1':[h1,h2], 'l2':[h3,h4], 'l3':[h5,h6], 'l4':[h7,h8]})

    # Optional: VLAN isolation
    if enable_vlan:
        info('*** Enabling VLAN tagging on leaf access ports: 10 for l1/l2, 20 for l3/l4\n')
        tag_vlan_on_leaf_access(l1, [l1_h1, l1_h2], vlan_id=10)
        tag_vlan_on_leaf_access(l2, [l2_h3, l2_h4], vlan_id=10)
        tag_vlan_on_leaf_access(l3, [l3_h5, l3_h6], vlan_id=20)
        tag_vlan_on_leaf_access(l4, [l4_h7, l4_h8], vlan_id=20)
        deny_for_10 = ['10.3.0.0/16', '10.4.0.0/16']
        deny_for_20 = ['10.1.0.0/16', '10.2.0.0/16']
        install_acl_isolation('l1', deny_for_10)
        install_acl_isolation('l2', deny_for_10)
        install_acl_isolation('l3', deny_for_20)
        install_acl_isolation('l4', deny_for_20)

    # Optional: QoS
    if enable_qos:
        info('*** Attaching simple QoS (linux-htb) to leaf access ports\n')
        setup_qos_on_leaf_access(l1, [l1_h1, l1_h2])
        setup_qos_on_leaf_access(l2, [l2_h3, l2_h4])
        setup_qos_on_leaf_access(l3, [l3_h5, l3_h6])
        setup_qos_on_leaf_access(l4, [l4_h7, l4_h8])

    net.start()

    # Optional: ONOS programming
    if program_onos:
        info('*** Programming ONOS: activating core apps and posting sample intents\n')
        onos_activate_core_apps(ctrl_ip, user=onos_user, password=onos_pass)
        code, _ = onos_post_host_intent(ctrl_ip, 'org.onosproject.cli', mac_of(h1), mac_of(h2), user=onos_user, password=onos_pass)
        info(f"Intent h1↔h2: HTTP {code}\n")
        code, _ = onos_post_host_intent(ctrl_ip, 'org.onosproject.cli', mac_of(h3), mac_of(h4), user=onos_user, password=onos_pass)
        info(f"Intent h3↔h4: HTTP {code}\n")
        code, _ = onos_post_host_intent(ctrl_ip, 'org.onosproject.cli', mac_of(h5), mac_of(h6), user=onos_user, password=onos_pass)
        info(f"Intent h5↔h6: HTTP {code}\n")
        code, _ = onos_post_host_intent(ctrl_ip, 'org.onosproject.cli', mac_of(h7), mac_of(h8), user=onos_user, password=onos_pass)
        info(f"Intent h7↔h8: HTTP {code}\n")

    info('\n=== Topology summary ===\n')
    info(f"Controller  : {ctrl_ip}:{ctrl_port}\n")
    info("Spines      : s1, s2\n")
    info("Leaves      : l1, l2, l3, l4\n")
    info("Hosts       : h1–h8 (two per leaf)\n")
    info("OF protocol : OpenFlow13 (enforced)\n")
    if enable_vlan:
        info("Isolation   : VLANs (10: l1/l2, 20: l3/l4) + ACL drops between tenants\n")
    if enable_qos:
        info("QoS         : linux-htb queues on access ports (queues 0/1)\n")
    if program_onos:
        info("Controller  : ONOS apps activated; sample host intents installed\n")
    info('========================\n\n')

    # Hand over to CLI then teardown
    CLI(net)
    net.stop()


# -------------------------------------------------------------------
# Tiny self tests (pure‑python; safe without Mininet/ONOS)
# -------------------------------------------------------------------

def run_tests():
    class _FakeHost:
        def __init__(self, mac):
            self._mac = mac
        def MAC(self):
            return self._mac
        def setIP(self, *_):
            self.ip = _  # store but unused
    fh = _FakeHost('aa:bb:cc:dd:ee:ff')
    assert mac_of(fh) == 'aa:bb:cc:dd:ee:ff', 'mac_of() failed'
    code, _ = onos_rest('1.2.3.4', '/onos/v1/foo', method='GET', dry_run=True)
    assert code == 0, 'dry-run REST should return code 0'
    class _FakeLeaf:
        name = 'lX'
        def cmd(self, *_):
            raise AssertionError('cmd() should not be called in dry-run test')
    fake_leaf = _FakeLeaf()
    setup_qos_on_leaf_access(fake_leaf, [], dry_run=True)
    tag_vlan_on_leaf_access(fake_leaf, [], vlan_id=10, dry_run=True)
    install_acl_isolation('lX', ['10.9.0.0/16'], dry_run=True)
    # Lazy import should raise RuntimeError in non‑Linux/non‑Mininet envs
    try:
        _lazy_import_mininet()
    except RuntimeError:
        pass
    print('ALL TESTS PASSED')


# -------------------------------------------------------------------
# Main
# -------------------------------------------------------------------

if __name__ == '__main__':
    setLogLevel('info')
    parser = argparse.ArgumentParser(description='Spine–Leaf topology for ONOS')
    parser.add_argument('--ctrl_ip', type=str, default='127.0.0.1', help='ONOS controller IP')
    parser.add_argument('--ctrl_port', type=int, default=6653, help='ONOS OpenFlow port (default 6653)')
    parser.add_argument('--enable_vlan', action='store_true', help='Enable VLAN tags on leaf access ports (10/20)')
    parser.add_argument('--enable_qos', action='store_true', help='Enable simple QoS queues on leaf access ports')
    parser.add_argument('--program_onos', action='store_true', help='Activate ONOS apps + add sample intents')
    parser.add_argument('--onos_user', type=str, default='onos', help='ONOS REST username')
    parser.add_argument('--onos_pass', type=str, default='rocks', help='ONOS REST password')
    parser.add_argument('--dry_run', action='store_true', help='Do not make REST/OVS changes; print actions only')
    parser.add_argument('--run_tests', action='store_true', help='Run built‑in self tests and exit')
    args = parser.parse_args()

    if args.run_tests:
        run_tests()
        sys.exit(0)

    try:
        build_topology(
            args.ctrl_ip, args.ctrl_port,
            enable_vlan=args.enable_vlan,
            enable_qos=args.enable_qos,
            program_onos=args.program_onos,
            onos_user=args.onos_user, onos_pass=args.onos_pass,
            dry_run=args.dry_run
        )
    except Exception as e:
        sys.stderr.write(f"\n[ERROR] {e}\n")
        sys.stderr.write("Tip: For full Mininet run, execute inside a Linux VM with Mininet + OVS installed. Use --dry_run elsewhere.\n")
        raise